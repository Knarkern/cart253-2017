class: middle

# CART 253 | 07 | Math tricks

???

- Today's class is pretty free-form
- Intended as something of a respite after the Midterm
- Will just look at a bunch of tricks available from math
- The book has a large number of these
- We'll just look at some

---

# Today

## Exercise 04?
## Math tricks
## Geometry tricks
## A couple of extras
## The final project

---

# Exercise 04?

---

class: middle

# Math tricks

---

# MATH???

- Many of us do not necessarily love mathematics
- And that is okay
- That is perfectly okay
- What we want to do today is use math _tricks_
- We don't necessarily need a deep understanding of the underlying maths
- So long as we can use the approaches themselves

---

# Math.

- We already do a bunch of math in our programming anyway

```java
x = width/2;
...
avatarX += vx;
```

- And logic, which relies on mathematical comparisons

```java
if (mathIsAwesome && theAwesomenessOfMath >= 100)
```

- And even fancy math like Pythagoras' theorem...

```java
int mouseDistance = dist(x,y,mouseX,mouseY);
```

---

# Modulo

- Modulo is an operator like `+`, `-`, `*`, `\`, etc...
- It is represented by a percentage sign: `%`
- It calculates the _remainder after division_ for two numbers
- So `20 % 15` is `5`
- Because `15` divides into `20` once with `5` left over

---

# Modulooooooo

`50 % 10 == 0`

Because `10` divides into `50` five times perfectly with no remainder

`10 % 3 == 1`

Because `3` divides into `10` three times with `1` left over

`27 % 5 == `
--

`2`, because `5` divides into `27` five times with `2` left over
--


`50 % 255 == `

--
`50`, because `255` does not divide into `50` at all

(Not a very common thing to check, as far as I know.)

---

# Modulo is good at limiting a number to a range

```
0 % 5 == 0
1 % 5 == 1
2 % 5 == 2
3 % 5 == 3
4 % 5 == 4
5 % 5 == 0
6 % 5 == 1
7 % 5 == 2
8 % 5 == 3
9 % 5 == 4
10 % 5 == 0
11 % 5 == 1
```

- If we have an increasing number and always modulo by `5` then we always get back a number between `0` and `4`

---

# Modulo for colour

```java
int blueness = 0;

void draw()
{
  background(0,0,blueness);
  blueness = (blueness + 1) % 255;
}
```

---

# Module for animation

```java
int[] sizes = {0,10,15,20,25,30,35,40};
int i = 0;

void draw()
{
  background(0);
  rectMode(CENTER);
  rect(width/2,height/2,sizes[i],sizes[i]);
  i = (i + 1) % sizes.length;
}
```

- This is pretty classic as a way to go through an array in time and wrapping around at the end


---

# `random()!`

- We're already pretty familiar with Processing's random().
- All hail the madness of

```java
background(random(0,255),random(0,255),random(0,255));
```

- In short, yay for getting back a number you're not expecting!

---

# "`random()`"

- The numbers that come out of `random()` are actually "pseudorandom numbers".
- That's because they're generated by an equation, and thus naturally have a pattern over time.
- Fortunately the pattern is so huge and varied that the numbers may as well be random as far as we're concerned.
- Generating a truly random number is a lot harder than you would imagine.

---

# "`random()`"!

- Note that it can be _useful_ to have pseudorandomness because it means it's _repeatable_
- In particular, when you use random numbers you can specify a _seed_ value that determines how the random numbers are generated
- And if you use the _same seed_ you get the _same_ sequence of random numbers
- In Processing we can set the random seed with

```java
randomSeed(number);
```

---

# "`random()`"!

- We can test this with this code

```java
randomSeed(0);
for (int i = 0; i < 10; i++) {
  println(random(10));
}
```

- It returns the same ten "random" numbers every time
- But if we comment out `randomSeed(0);` we'll get different sequences each time
- Could be useful!

---

# Uniformly `random()`

- A nice quality of the `random()` function is that it has a _uniform distribution_
- That means that any given number is returns is _just as likely as any other_
- They all have the same probability of occurring, so with

```java
int value = floor(random(0,10));
```

- There is a 10% chance of `0`, a 10% chance of `1`, a 10% chance of `2`, ... a 10% chance of `8`, and a 10% chance of `9`

---

# `random()` can be used as a probability generator!

- Given this uniform distribution, we can use `random()` to do things in our code with specific probabilities!

```java
float value = random(0,1);

if (value < 0.01) {
  println("Ultra rare loot drop! 1% chance of this!");
}
else if (value < 0.06) {
  println("Pretty rare loot drop! 5% chance of this!");
}
else if (value < 0.16) {
  println("Kind of rare loot drop! 10% chance of this!");
}
else if (value < 0.5) {
  println("Okay loot drop. 34% chance of this...");
}
else {
  println("The same rusty battle-axe you always find. 50% chance of this.");
}
```

---

# `random()`ish

- One nice thing you can do with randomness is to generate values that are random but _related_ to each other
- There is a lovely function in Processing called `noise()` that can do this kind of thing
- It generates _Perlin noise_, which is a sequence of related random numbers

```java
float value = noise(t);
```

- Where `t` is a "time" value
- And it returns a number between `0` and `1`

---

# Timeless `noise()`

```java
float t = 0;

void draw() {
  float n = noise(t);
  println(n);
}
```
--

- Crappy. It just gives back the same number every time. Because?
--

- Yeah, the value of "time" is not changing.

---

# `noise()` time!

```java
float t = 0;

void draw() {
  float n = noise(t);
  println(n);
  time += 0.01;
}
```

- We've got all the time in the world!

---

# Graphing `noise()`

- We can use the fact that `noise()` returns a value between `0` and `1` to apply it to our programs

```java
float t = 0;
int x = 0;

void setup() {
  size(600,600);
  background(0);
  stroke(255);
}

void draw() {
  float n = noise(t);
  float r = random(0,1);
  ellipse(x,n*height,5,5);
  x++;
  t += 0.01;
}
```

???

Try this with both `n*height` and `r*height` to see the behaviour of `noise()` and `random()` respectively

---

# Using `noise()`

- Naturally just graphing the values of noise isn't that interesting
- But we can use the fact we get this stream of related random numbers between `0` and `1` to affect other numbers
- Such as the velocity of an agent, the location of an agent, the size of an image, the colour of the background...

---

# Pet `noise()`

```java
float t = 0.0;

void setup() {
  size(500,500);
}

void draw() {
  background(0);
  float petOneX = width*noise(t);
  ellipse(petOneX,100,20,20);
  float petTwoX = width*noise(t);
  ellipse(petTwoX,400,20,20);
  t += 0.01;
}
```

---

# Independent pets

```java
float t1 = random(0,100);
float t2 = random(0,100);

void setup() {
  size(500,500);
}

void draw() {
  background(0);
  float petOneX = width*noise(t1);
  ellipse(petOneX,100,20,20);
  float petTwoX = width*noise(t2);
  ellipse(petTwoX,400,20,20);
  t1+= 0.01;
  t2+= 0.01;
}
```

---

# Run free, pet! Run free!

```java
float tx = random(0,100);
float ty = random(0,100);

void setup() {
  size(500,500);
}

void draw() {
  background(0);
  float x = width * noise(tx);
  float y = height * noise(ty);
  ellipse(x,y,20,20);
  tx += 0.01;
  ty += 0.01;
}
```

---

# A pet with velocity

```java
float tx = random(0,100);
float ty = random(0,100);
float speed = 10;
float x;
float y;

void setup() {
  size(500,500);
  x = width/2;
  y = height/2;
}

void draw() {
  background(0);
  float vx = speed * (noise(tx) * 2 - 1);
  float vy = speed * (noise(ty) * 2 - 1);
  x += vx;
  y += vy;
  ellipse(x,y,20,20);
  tx += 0.01;
  ty += 0.01;

  // Check for wrapping?
}
```

???

- Code to check for wrapping:

```java

  if (x < 0) {
    x += width;
  }
  else if (x > width) {
    x -= width;
  }
  if (y < 0) {
    y += height;
  }
  else if (y > height) {
    y -= height;
  }
```

---

# Make some `noise()` for `noise()`

- It's a pretty great function
- In particular it feels quite organic
- Because the behaviour of living things often feels like a series of related but unpredictable decisions from the outside

---

# Check this out for the hell of it...

```java
noiseDetail(16,0.6);
size(500, 500);

for (int i = 0; i < width*height; i++) {
  float x = i % width;
  float y = (i / width);
  float n = noise(x/width,y/height);
  color c = color(n * 255);
  stroke(c);
  point(x, y);
}
```

---

# Recursion?

- Nah.
- But if you want to read about it, check out the textbook!

---

# 2D Arrays?

- We'll run into these next week.
- It's worth reading about them in the textbook.
- The basic point is that you can have an _array_ with elements that are _arrays_ as well

```java
size(400,400);
int[][] my2DArray = new int[height][width];

for (int y = 0; y < my2DArray.length; y++) {
  for (int x = 0; x < my2DArray[y].length; x++) {
    stroke(random(255));
    point(x,y);
  }
}
```

---

class: middle

# Geometry tricks

---

# Remember angles?

- You know, like 90ยบ and 180ยบ and so on?
- Those are angles in _degrees_

---

# Meet radians...

- Radians are a different way of measuring an angle
- They represent the ratio of the arc made by the angle to its radius

- All of Processing's functions that deal with angles use _radians_, __not__ degrees
---

# Meet `radians()`

- Fortunately, if you prefer to think in degrees, you can
- Because Processing can convert for you

```java
float rightAngleInRadians = radians(90);

float rightAngleInDegrees = degrees(rightAngleInRadians);
```

---

# The polar coordinates express

- We are used to expressing where something is on the screen according to _Cartesian coordinates_
- That is we give an `x` and `y`, where `x` is the distance in pixels from the origin to our point horizontally, and `y` is the distance in pixels from the origin to our point vertically
--

- But there is another coordinate systems called _polar coordinates_
- Which gives a `r` and a `theta`, where `r` is the distance in a straight line from the origin to our point and `theta` is the angle that straight lines needs to be at to reach the point
--

- Frankly I find polar coordinates underwhelming most of the time
- If they sound exciting to you, I suggest reading about them!

---

# Better keep it oscillated

- A great feature of trigonometric functions is _oscillation_
- Functions like _sine_ and _cosine_ oscillate between `-1` and `1` as the angle you give them changes

```java
float theta = 0;
int x = 0;

void setup() {
  size(600,600);
  background(0);
  fill(255);
}

void draw() {
  float y = height/2 + (sin(theta) * height/2);
  ellipse(x,y,10,10);
  x++;
  theta += 0.05;
}
```

---

# Just another number

- The numbers that come out of `sin()` as you increase the angle are just more numbers (between `-1` and `1` this time) that you can apply to something else...

```java
float theta = 0;
float size = 300;

void setup() {
  size(600,600);
  background(0);
  fill(255);
}

void draw() {
  float growth = sin(theta) * (size/4);
  ellipse(width/2,height/2,size + growth,size + growth);
  theta += 0.05;
}
```

---

# Origin story

- Remember the origin?
- That's where `0,0` is in the window
- Which is where?
--
 Yeah, the _top left_ of the window

--
- But it doesn't have to be there!
--

- And it could be useful to put it somewhere else, depending on what you're doing
- It might be helpful to have it in the centre of the window, for instance, if you're drawing symmetric things

---

# Move it

Compare

```java
size(500,500);
rectMode(CENTER);
rect(0,0,100,100);
```

with

```java
size(500,500);
rectMode(CENTER);
translate(width/2,height/2);
rect(0,0,100,100);
```
--

So `translate(x,y)` _moves_ the origin to the location specified.

---

# Move it, move it

- Actually `translate(x,y)` is cumulative, compare:

```java
void draw() {
  translate(40,40); // Origin now at 40,40
  rect(0,0,10,10);
}
```

```java
void draw() {
  translate(40,40); // Origin now at 40,40
  translate(40,40); // Origin now at 80,80
  rect(0,0,10,10);
}
```

(Note: `translate()` gets reset at the start of `draw()` each time)


---

# You spin me right round...

- Being able to control where the origin is useful for _rotation_
- Because in Processing things rotate _around the origin_
- Using a function called `rotate()`

```java
size(500,500);
rotate(radians(45));
rectMode(CENTER);
rect(width/2,height/2,100,100);
```
--

- Wait what? We probably thought this would rotate the rectangle around _its own centre_
- But... no.

---

# You spin me right round the origin

- We need to remember that `rotate()` will rotate around the _origin_
- So if we want to rotate our rectangle around its centre we need to...
--

- `translate()` the origin to the centre of the rectangle and _then_ rotate it
--

```java
size(500,500);
translate(width/2,height/2);
rotate(radians(45));
rectMode(CENTER);
rect(width/2,height/2,100,100);
```
--
- Wait, what?

---

# You spin me right round the origin and the origin is at `0,0`

- When we `translate()` the origin, we need to remember that `0,0` is now in a new location, so

```java
size(500,500);
translate(width/2,height/2);
rotate(radians(45));
rectMode(CENTER);
rect(0,0,100,100);
```

---

# One more time with feeling...

```java
float theta = 0;

void setup() {
  size(500,500);
}

void draw() {
  background(0);
  translate(width/2,height/2);
  rotate(theta);
  rectMode(CENTER);
  rect(0,0,100,100);
  theta += 0.01;
}
```

---

# Scaling

- Along with `rotate()` we get `scale()`
- `scale()` does what you might expect: it scales things by the amount you tell it to
- `scale(2)` scales things up by 2 times
- `scale(0.5)` scales things down to half their size
--

- But it scales things _around the origin_
- So, same rules apply

---

# Scaling as we go

```java
float theScale = 1;

void setup() {
  size(500,500);
}

void draw() {
  background(0);
  translate(width/2,height/2);
  scale(theScale);
  rectMode(CENTER);
  rect(0,0,100,100);
  theScale += 0.01;
}
```

---

# Didn't I hear something about a 3rd dimension?

- Processing can do things in 3D as well as in 2D
- You can read all about it in the textbook
- For now, know that you need to tell Processing to use 3D specifically in the `size()` function:

```java
size(640,480,P3D);
```

---

# What can I do?

- Again, read the book, but... you can use `translate()`, `rotate()`, and `scale()` in all three dimensions...

```java
translate(x,y,z);
rotateX(angle);
rotateY(angle);
rotateZ(angle);
scale(xScale,yScale,zScale);
```

- And there are 3D primitives like

```java
box(100,100,100); // Draw a box with sides of size 100 at the origin
```

- Again, most of the time you'll want to _translate_ the origin, apply rotation and scale, then draw your thing...

---

# Like...

```java
float theta = 0;
float scaleFactor = 1;

void setup() {
  size(640,480,P3D);
}

void draw() {
  background(0);
  translate(width/2,height/2,0); // Translating in THREE DIMENSIONS!
  rotateX(radians(45));
  rotateY(theta);
  scale(scaleFactor);
  box(50,50,50);
  theta += 0.01;
  scaleFactor += 0.01;
}
```
--

- Nice!

---

# How about...

```java
float theta1 = 0.0;
float theta2 = 0.0;

void setup() {
  size(500,500,P3D);
}

void draw() {
  background(0);
  translate(250,250);
  rotateY(theta1);
  box(60);
  translate(50,50);
  rotateX(theta2);
  box(30);
  theta1 += 0.01;
  theta2 -= 0.01;
}
```
--

- Cool, but I wanted those two boxes to rotate _separately_!

---

# Cumulative effects again

- Notice how that first `rotateY()` is being applied to the _second_ box as well
- It's cool because it's like the second box orbits the first
- But you might want to be able to do rotations etc. completely separately

---

# Enter the Matrix

- Processing has a thing called the _transformation matrix_ that keeps track of all the rotations, translations, scalings, etc. that you apply
- So far we're just applying everything to the main transformation matrix
- But we can create separate matrices to keep effects separate

---

# Separate rotations

```java
float theta1 = 0.0;
float theta2 = 0.0;

void setup() {
  size(500,500,P3D);
}

void draw() {
  background(0);
  pushMatrix();
  translate(250,250);
  rotateY(theta1);
  box(60);
  popMatrix();
  pushMatrix();
  translate(50,50);
  rotateX(theta2);
  box(30);
  popMatrix();
  theta1 += 0.01;
  theta2 -= 0.01;
}
```

---

# Problem solved

- So, if you want to keep effects separate...
- Put them in between a `pushMatrix()` and a `popMatrix()`
- And all will be well!
- `pushMatrix()` basically means "let's start a new matrix and apply some new transformations"
- `popMatrix()` basically means "I'm done with that matrix, forget the transformations I applied now"
- (Note that any transformations applied _before_ your `pushMatrix()` will still be active, unless they were inside a `pushMatrix()`/`popMatrix()` pair)

---

# Nested pushing and popping...

- Example 14-17 in the book has a kind of amazing visual structure
- I find it very hard to understand, but it's interesting
- (See presenter notes.)

???

```java
// Global angle for rotation
float theta = 0;

void setup() {
  size(200, 200);
}

void draw() {
  background(100);
  stroke(255);
  // Translate to center of window
  translate(width/2, height/2);
  // Loop from 0 to 360 degrees (2*PI radians)
  for (float i = 0; i < TWO_PI; i += 0.2) {
    // Push, rotate and draw a line!
    pushMatrix();
    rotate(theta + i);
    line(0, 0, 100, 0);
    // From 0 to 360 degrees (2*PI radians)
    for (float j = 0; j < TWO_PI; j += 0.5) {
      // Push, translate, rotate!
      pushMatrix();
      translate(100, 0);
      rotate(-theta - j);
      line(0, 0, 50, 0);
      // Done with the inside loop, pop!
      popMatrix();
    }
    // Done with the outside loop, pop!
    popMatrix();
  }
  endShape();
  // Increment theta
  theta += 0.01;
}
```

---

class: middle

# A couple of extras

---

# `ArrayList`

- If you want a slightly more flexible way of keeping a bunch of things together, there is the `ArrayList`
- Note that `ArrayList`s can _only store objects_ (not `int`, `float`, etc.)
- You make one like this

```java
ArrayList bouncers = new ArrayList(); // Notice how you don't have to say how long it is
```

- And you add things to it like this

```java
bouncers.add(new Bouncer(width/3,height/2));
bouncers.add(new Bouncer(2*width/3,height/2));
```

---

# `ArrayList`

- An `ArrayList` still has the same idea of _numbered boxes_ (elements with indexes)
- So you can get hold of an element like this

```java
Bouncer bouncer = (Bouncer)bouncers.get(1);
bouncer.update();
bouncer.display();
```

- Notice how you have to _cast_ the thing that comes out of `.get()` into the type of object it is
- An `ArrayList` doesn't know what specific kind of thing is inside it

---

# `ArrayList`

- An `ArrayList` makes it really easy to take something _out_ as well:

```java
bouncers.remove(1);
```

- Note that you should check if there's really something _there_ before trying to remove it
- You can check how many elements are in an `ArrayList` with `.size()`...

```java
println("The length of the ArrayList is " + bouncers.size());
```

---

# `ArrayList++`

- There's a lot more to know about `ArrayList`s
- If you want to know more, this is a nice summary

https://beginnersbook.com/2013/12/java-arraylist/

- But be aware there are other methods like `.contains()`, `.indexOf()`, `.set()`, and more!
- Handy!

---

# Dynamic window resizing!

- You can resize the window _while your program is running_

```java
void setup() {
  size(200,200);
  surface.setResizable(true); // Put this in setup
}

void draw() {
  println(width,height);
}

void mouseClicked() {
  surface.setSize(1000,20); // Change size with this
}
```

- Note that `surface.setResizable(true)` means the user will also be able to resize the window _with their mouse_
- Could be a game in that!

---

# A timer

- To make a simple timer that we can use for timed events we can use `millis()`
- `millis()` returns the number of milliseconds _since the program started running_
- So if you store the _current_ value of millis() at a specific moment you can check how much time has passed since then

---

```java
boolean timerRunning = false;
int startTime = 0;

void draw() {
  if (timerRunning) {
    int timeElapsed = (millis() - startTime)/1000;
    println(timeElapsed);
  }
}

void keyPressed() {
  if (key == 's') {
    startTime = millis();
    timerRunning = true;
  } else if (key == 'x') {
    timerRunning = false;
  }
}
```

- There's an example of a Timer class in the presenter notes

???

```java
class Timer {
  // The value of millis() when the timer was started
  int startTime;
  // The number of milliseconds that have elapsed for the timer
  // Need this for pausing
  int elapsed = 0;
  // The time this timer is set for (in milliseconds)
  int time;
  // Whether or not the timer is active
  boolean running = false;
  // Whether or not the timer is paused
  boolean paused = false;

  // Timer (int tempTime)
  //
  // Create a new timer with a set number of milliseconds to count to

  Timer(int tempTime) {
    time = tempTime;
  }

  // start()
  //
  // Start the timer running

  void start() {
    // Don't start the timer if it's already running and not paused
    if (running && !paused) {
      return;
    }

    // Remember the time it was started (or restarted if paused)
    startTime = millis();
    // Remember that it's running
    running = true;
    // And that it's not paused (if it was)
    paused = false;
  }

  // pause()
  //
  // Pause the timer

  void pause() {
    // Don't pause if the timer is stopped or paused
    if (!running || paused) {
      return;
    }

    // Remember it's paused
    paused = true;
    // Add the time that elapsed up to the pause to our elapsed variable
    // So we can remember the cumulative amount of time
    elapsed += (millis() - startTime);
  }

  // stop()
  //
  // Stop the timer completely and reset it

  void stop() {
    running = false;
    elapsed = 0;
  }

  // isDone()
  //
  // Returns true if the elapsed time is greater than the set time
  // and false otherwise
  boolean isDone() {
    // If the timer isn't running or it's paused, then it isn't
    // done
    if (!running || paused) {
      return false;
    }

    // Add the elapsed time since the last time it was started
    // so we know how much time has passed
    elapsed += (millis() - startTime);
    // Remember the new start time (now) so that we can count
    // time elapsed since this check
    startTime = millis();

    // Check if the elapsed time is greater than the set time
    // and return the result
    if (elapsed >= time) {
      return true;
    } else {
      return false;
    }
  }
}
```

---

# The final project

- [The final project](https://github.com/pippinbarr/cart253-2017/wiki/Final-Project) is now a real thing on the wiki
- Let's take a look (it's pretty "simple")
- Next week you must come in with one or more concepts and a basic idea of how you're going to program it (I will ask)

---

# Homework/Nowwork

- __Now:__ Finish [Exercise 04](https://github.com/pippinbarr/cart253-2017/wiki/Exercise-04)
- __Nowish:__ Start [Exercise 05](https://github.com/pippinbarr/cart253-2017/wiki/Exercise-05), due next week
- __Around nowish:__ Think about the [Final Project](https://github.com/pippinbarr/cart253-2017/wiki/Final-Project) and prepare your concept and technical pitch for next week
- The readings for _next week_ are Chapters 12 and 15 of _Learning Processing_ (Libraries and Images)
- The readings for _this week_ were Chapters 13 and 14 of _Learning Processing_ (Mathematics and Translation and Rotation)
